Two pointers: one input, opposite ends

public int fn(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    int ans = 0;

    while (left < right) {
        // do some logic here with left and right
        if (CONDITION) {
            left++;
        } else {
            right--;
        }
    }

    return ans;
}
------------------------------------------------------
Two pointers: two inputs, exhaust both

public int fn(int[] arr1, int[] arr2) {
    int i = 0, j = 0, ans = 0;

    while (i < arr1.length && j < arr2.length) {
        // do some logic here
        if (CONDITION) {
            i++;
        } else {
            j++;
        }
    }

    while (i < arr1.length) {
        // do logic
        i++;
    }

    while (j < arr2.length) {
        // do logic
        j++;
    }

    return ans;
}
------------------------------------------------------
Two pointers: reverse

public static void reverse(int[] v, int N) {
    int i = 0;
    int j = N - 1;
    while (i < j) {
        swap(v, i, j);  // this is a self-defined function
        i++;
        j--;
    }
}
------------------------------------------------------
Sliding window

public int fn(int[] arr) {
    int left = 0, ans = 0, curr = 0;

    for (int right = 0; right < arr.length; right++) {
        // do logic here to add arr[right] to curr

        while (WINDOW_CONDITION_BROKEN) {
            // remove arr[left] from curr
            left++;
        }

        // update ans
    }

    return ans;
}
------------------------------------------------------
Build a prefix sum

public int[] fn(int[] arr) {
    int[] prefix = new int[arr.length];
    prefix[0] = arr[0];

    for (int i = 1; i < arr.length; i++) {
        prefix[i] = prefix[i - 1] + arr[i];
    }

    return prefix;
}
------------------------------------------------------
Linked list: fast and slow pointer

public int fn(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    int ans = 0;

    while (fast != null && fast.next != null) {
        // do logic
        slow = slow.next;
        fast = fast.next.next;
    }

    return ans;
}
------------------------------------------------------
Linked list: reversing

public ListNode fn(ListNode head) {
    ListNode curr = head;
    ListNode prev = null;
    while (curr != null) {
        ListNode nextNode = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextNode;
    }

    return prev;
}
------------------------------------------------------
Linked list: merge with dummy pointer

var mergeTwoLists = function(list1, list2) {

    // using dummy head to avoid writing additional code for edge cases (e.g. list = null).
    // using "new" keyword to create a new object. It makes the this variable point to the newly created object.
	// p is the pointer of dummy, p1 is the pointer of list1, p2 is the pointer of list2
    let dummy = new ListNode(0);
    let p = dummy;
    let p1 = list1;
    let p2 = list2;

    //   while both lists are not null.
    while (p1 && p2 ){

        // compare the number of nodes. insert the smaller node to the result
        if (p1.val > p2.val){
            p.next = p2;
            p2 = p2.next;
        }else{
            p.next = p1;
            p1 = p1.next;
        }

        // move the pointer to the next one
        p = p.next;
    }

    // if every node of one list has been traversaled, we will insert the rest of the other list to the result
    p.next = p1 || p2;
    return dummy.next;
};
------------------------------------------------------

Find number of subarrays that fit an exact criteria

public int fn(int[] arr, int k) {
    Map<Integer, Integer> counts = new HashMap<>();
    counts.put(0, 1);
    int ans = 0, curr = 0;

    for (int num: arr) {
        // do logic to change curr
        ans += counts.getOrDefault(curr - k, 0);
        counts.put(curr, counts.getOrDefault(curr, 0) + 1);
    }

    return ans;
}
------------------------------------------------------
Monotonic increasing stack

public int fn(int[] arr) {
    Stack<Integer> stack = new Stack<>();
    int ans = 0;

    for (int num: arr) {
        // for monotonic decreasing, just flip the > to <
        while (!stack.empty() && stack.peek() > num) {
            // do logic
            stack.pop();
        }

        stack.push(num);
    }

    return ans;
}
------------------------------------------------------
Binary tree: DFS (recursive)

public int dfs(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int ans = 0;
    // do logic
    dfs(root.left);
    dfs(root.right);
    return ans;
}
------------------------------------------------------
Binary tree: DFS (iterative)

public int dfs(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    int ans = 0;

    while (!stack.empty()) {
        TreeNode node = stack.pop();
        // do logic
        if (node.left != null) {
            stack.push(node.left);
        }
        if (node.right != null) {
            stack.push(node.right);
        }
    }

    return ans;
}
------------------------------------------------------
Binary tree: BFS

public int fn(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int ans = 0;

    while (!queue.isEmpty()) {
        int currentLength = queue.size();
        // do logic for current level

        for (int i = 0; i < currentLength; i++) {
            TreeNode node = queue.remove();
            // do logic
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }

    return ans;
}
------------------------------------------------------
Graph: DFS (recursive)

Set<Integer> seen = new HashSet<>();

public int fn(int[][] graph) {
    seen.add(START_NODE);
    return dfs(START_NODE, graph);
}

public int dfs(int node, int[][] graph) {
    int ans = 0;
    // do some logic
    for (int neighbor: graph[node]) {
        if (!seen.contains(neighbor)) {
            seen.add(neighbor);
            ans += dfs(neighbor, graph);
        }
    }

    return ans;
}
------------------------------------------------------
Graph: DFS (iterative)

public int fn(int[][] graph) {
    Stack<Integer> stack = new Stack<>();
    Set<Integer> seen = new HashSet<>();
    stack.push(START_NODE);
    seen.add(START_NODE);
    int ans = 0;

    while (!stack.empty()) {
        int node = stack.pop();
        // do some logic
        for (int neighbor: graph[node]) {
            if (!seen.contains(neighbor)) {
                seen.add(neighbor);
                stack.push(neighbor);
            }
        }
    }

    return ans;
}
------------------------------------------------------
Graph: BFS

public int fn(int[][] graph) {
    Queue<Integer> queue = new LinkedList<>();
    Set<Integer> seen = new HashSet<>();
    queue.add(START_NODE);
    seen.add(START_NODE);
    int ans = 0;

    while (!queue.isEmpty()) {
        int node = queue.remove();
        // do some logic
        for (int neighbor: graph[node]) {
            if (!seen.contains(neighbor)) {
                seen.add(neighbor);
                queue.add(neighbor);
            }
        }
    }

    return ans;
}
------------------------------------------------------
Find top k elements with heap

public int[] fn(int[] arr, int k) {
    PriorityQueue<Integer> heap = new PriorityQueue<>(CRITERIA);
    for (int num: arr) {
        heap.add(num);
        if (heap.size() > k) {
            heap.remove();
        }
    }

    int[] ans = new int[k];
    for (int i = 0; i < k; i++) {
        ans[i] = heap.remove();
    }

    return ans;
}
------------------------------------------------------
Binary search

public int fn(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            // do something
            return mid;
        }
        if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    // left is the insertion point
    return left;
}
------------------------------------------------------
Binary search: duplicate elements, left-most insertion point

public int fn(int[] arr, int target) {
    int left = 0;
    int right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] >= target) {
            right = mid
        } else {
            left = mid + 1;
        }
    }

    return left;
}
------------------------------------------------------
Binary search: duplicate elements, right-most insertion point

public int fn(int[] arr, int target) {
    int left = 0;
    int right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] > target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}
------------------------------------------------------
Binary search: for greedy problems
(If looking for a minimum:)

public int fn(int[] arr) {
    int left = MINIMUM_POSSIBLE_ANSWER;
    int right = MAXIMUM_POSSIBLE_ANSWER;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

public boolean check(int x) {
    // this function is implemented depending on the problem
    return BOOLEAN;
}
------------------------------------------------------
Binary search: for greedy problems
If looking for a maximum:

public int fn(int[] arr) {
    int left = MINIMUM_POSSIBLE_ANSWER;
    int right = MAXIMUM_POSSIBLE_ANSWER;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return right;
}

public boolean check(int x) {
    // this function is implemented depending on the problem
    return BOOLEAN;
}
------------------------------------------------------
Backtracking

public int backtrack(STATE curr, OTHER_ARGUMENTS...) {
    if (BASE_CASE) {
        // modify the answer
        return 0;
    }

    int ans = 0;
    for (ITERATE_OVER_INPUT) {
        // modify the current state
        ans += backtrack(curr, OTHER_ARGUMENTS...)
        // undo the modification of the current state
    }
}
------------------------------------------------------
Dynamic programming: top-down memoization

Map<STATE, Integer> memo = new HashMap<>();

public int fn(int[] arr) {
    return dp(STATE_FOR_WHOLE_INPUT, arr);
}

public int dp(STATE, int[] arr) {
    if (BASE_CASE) {
        return 0;
    }

    if (memo.contains(STATE)) {
        return memo.get(STATE);
    }

    int ans = RECURRENCE_RELATION(STATE);
    memo.put(STATE, ans);
    return ans;
}
------------------------------------------------------
Dynamic programming: bottom-up

F = array of length (n + 1) // to keep states
F[0] = 0
F[1] = 1
for i from 2 to n: // for each state apply FUNCTION
    F[i] = F[i - 1] + F[i - 2]
------------------------------------------------------
Build a trie

class TrieNode {
    // you can store data at nodes if you wish
    int data;
    Map<Character, TrieNode> children;
    TrieNode() {
        this.children = new HashMap<>();
    }
}

public TrieNode buildTrie(String[] words) {
    TrieNode root = new TrieNode();
    for (String word: words) {
        TrieNode curr = root;
        for (char c: word.toCharArray()) {
            if (!curr.children.containsKey(c)) {
                curr.children.put(c, new TrieNode());
            }

            curr = curr.children.get(c);
        }

        // at this point, you have a full word at curr
        // you can perform more logic here to give curr an attribute if you want
    }

    return root;
}
------------------------------------------------------
Adjacency list
Map<Integer, List<Pair<Integer, Integer>>> adj = new HashMap<>()
Map<Integer, List<int[]>> adj = new HashMap<>()
Map<Integer, HashMap<Integer,Integer>> adjList = new HashMap<>();
Map<Integer, List<int[]>> adjList = new HashMap<>();
------------------------------------------------------
Dijkstra's algorithm

int[] distances = new int[n];
Arrays.fill(distances, Integer.MAX_VALUE);
distances[source] = 0;

Queue<Pair<Integer, Integer>> heap = new PriorityQueue<Pair<Integer,Integer>>(Comparator.comparing(Pair::getKey));
heap.add(new Pair(0, source));

while (!heap.isEmpty()) {
    Pair<Integer, Integer> curr = heap.remove();
    int currDist = curr.getKey();
    int node = curr.getValue();

    if (currDist > distances[node]) {
        continue;
    }

    for (Pair<Integer, Integer> edge: graph.get(node)) {
        int nei = edge.getKey();
        int weight = edge.getValue();
        int dist = currDist + weight;

        if (dist < distances[nei]) {
            distances[nei] = dist;
            heap.add(new Pair(dist, nei));
        }
    }
}
------------------------------------------------------
Prim's Algorithm

public int minCostConnectPoints(int[][] points) {
    int N = points.length;

    Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));
    for (int i = 0; i < N; i++) {
        int[] next = points[i];
        int dist = calcDistance(points[0], next);
        queue.offer(new int[] {0, i, dist});
    }

    boolean[] seen = new boolean[N];
    seen[0] = true;
    int minCost = 0;
    int count = N-1;

    while (!queue.isEmpty() && count > 0) {
        int[] next = queue.poll();

        int curr = next[1];
        if (!seen[curr]) {
            seen[curr] = true;
            minCost += next[2];
            count--;

            for (int i = 0; i < N; i++) {
                if (!seen[i]) {
                    int dist = calcDistance(points[curr], points[i]);
                    queue.offer(new int[]{curr, i, dist});
                }
            }
        }
    }

    return minCost;
}

private int calcDistance(int[] a, int[] b) {
    return Math.abs(b[0] - a[0]) + Math.abs(b[1]-a[1]);
}
------------------------------------------------------
Kruskal Algorithm = Sort all edges + Union Find

public int minCostConnectPoints(int[][] points) {
    int N = points.length;

    int minCost = 0;

    PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N && j != i; j++) {
            int dist = Math.abs(points[j][0] - points[i][0]) + Math.abs(points[j][1] - points[i][1]);
            int[] edge = new int[]{i, j, dist};
            queue.offer(edge);
        }
    }
    UnionFind unionFind = new UnionFind(N);
    while (!queue.isEmpty()) {
        int[] next = queue.poll();
        if (unionFind.union(next[0], next[1])) {
            minCost += next[2];
        }
    }

    return minCost;
}

static class UnionFind {
    int[] root;
    int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            rank[i] = 1;
        }
    }

    boolean union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return false;
        if (rank[rootX] > rank[rootY]) {
            root[rootY] = rootX;
        } else if (rank[rootX] < rank[rootY]) {
            root[rootX] = rootY;
        } else {
            root[rootX] = rootY;
            rank[rootY] += 1;
        }
        return true;
    }

    int find(int x) {
        if (root[x] == x) {
            return x;
        }
        return root[x] = find(root[x]);
    }

}
------------------------------------------------------
Topological Sort

public List<Integer> findMinHeightTrees(int n, int[][] edges) {
    if (edges == null || edges.length == 0) return List.of(0);
    if (edges.length == 1) return List.of(edges[0][0], edges[0][1]);

    Set<Integer>[] adj = new Set[n];

    for (int[] edge : edges) {
        int from = edge[0];
        int to = edge[1];

        if (adj[from] == null) adj[from] = new HashSet<>();
        adj[from].add(to);

        if (adj[to] == null) adj[to] = new HashSet<>();
        adj[to].add(from);
    }

    Queue<Integer> queue = new LinkedList<>();

    for (int i = 0; i < adj.length; i++) {
        Set<Integer> neighbours = adj[i];
        if (neighbours != null && neighbours.size() == 1) {
            queue.offer(i);
        }
    }

    int round = queue.size();
    int nextRound = 0;

    while (n > 1 && round > 0) {
        Integer next = queue.poll();

        Set<Integer> neighbours = adj[next];
        if (neighbours != null) {
            for (Integer neighbour : neighbours) {
                Set<Integer> neighAdjs = adj[neighbour];

                if (neighAdjs != null) {
                    neighAdjs.remove(next);

                    if (neighAdjs.size() == 1) {
                        queue.offer(neighbour);
                        nextRound++;
                    }
                }
            }
        }

        n--; round--;
        if (round == 0 && n > 2) {
            round = nextRound;
            nextRound = 0;
        }

    }

    return new ArrayList<>(queue);
}
------------------------------------------------------
Quick Find - Disjoint Set

class UnionFind {
    private int[] root;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    public int find(int x) {
        return root[x];
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            for (int i = 0; i < root.length; i++) {
                if (root[i] == rootY) {
                    root[i] = rootX;
                }
            }
        }
    }

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
------------------------------------------------------
Quick Union - Disjoint Set

class UnionFind {
    private int[] root;

    public UnionFind(int size) {
        root = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
        }
    }

    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            root[rootY] = rootX;
        }
    }

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
------------------------------------------------------
Union by Rank - Disjoint Set

class UnionFind {
    private int[] root;
    private int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1;
        }
    }

    public int find(int x) {
        while (x != root[x]) {
            x = root[x];
        }
        return x;
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    }

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
------------------------------------------------------
Optimized “disjoint set” with Path Compression and Union by Rank

class UnionFind {
    private int[] root;
    // Use a rank array to record the height of each vertex, i.e., the "rank" of each vertex.
    private int[] rank;

    public UnionFind(int size) {
        root = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            root[i] = i;
            rank[i] = 1; // The initial "rank" of each vertex is 1, because each of them is
                         // a standalone vertex with no connection to other vertices.
        }
    }

	// The find function here is the same as that in the disjoint set with path compression.
    public int find(int x) {
        if (x == root[x]) {
            return x;
        }
        return root[x] = find(root[x]);
    }

	// The union function with union by rank
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] > rank[rootY]) {
                root[rootY] = rootX;
            } else if (rank[rootX] < rank[rootY]) {
                root[rootX] = rootY;
            } else {
                root[rootY] = rootX;
                rank[rootX] += 1;
            }
        }
    }

    public boolean connected(int x, int y) {
        return find(x) == find(y);
    }
}
------------------------------------------------------
Merge sort

public static void mergeSort(int[] a, int n) {
    if (n < 2) {
        return;
    }
    int mid = n / 2;
    int[] l = new int[mid];
    int[] r = new int[n - mid];

    for (int i = 0; i < mid; i++) {
        l[i] = a[i];
    }
    for (int i = mid; i < n; i++) {
        r[i - mid] = a[i];
    }
    mergeSort(l, mid);
    mergeSort(r, n - mid);

    merge(a, l, r, mid, n - mid);
}

public static void merge(
  int[] a, int[] l, int[] r, int left, int right) {

    int i = 0, j = 0, k = 0;
    while (i < left && j < right) {
        if (l[i] <= r[j]) {
            a[k++] = l[i++];
        }
        else {
            a[k++] = r[j++];
        }
    }
    while (i < left) {
        a[k++] = l[i++];
    }
    while (j < right) {
        a[k++] = r[j++];
    }
}
------------------------------------------------------
Quick sort

public void quickSort(int arr[], int begin, int end) {
    if (begin < end) {
        int partitionIndex = partition(arr, begin, end);

        quickSort(arr, begin, partitionIndex-1);
        quickSort(arr, partitionIndex+1, end);
    }
}

private int partition(int arr[], int begin, int end) {
    int pivot = arr[end];
    int i = (begin-1);

    for (int j = begin; j < end; j++) {
        if (arr[j] <= pivot) {
            i++;

            int swapTemp = arr[i];
            arr[i] = arr[j];
            arr[j] = swapTemp;
        }
    }

    int swapTemp = arr[i+1];
    arr[i+1] = arr[end];
    arr[end] = swapTemp;

    return i+1;
}
------------------------------------------------------
Counting sort

public void countingSort(int[] arr) {
    // Sorts an array of integers where minimum value is 0 and maximum value is K
    int K = Arrays.stream(arr).max().getAsInt();
    int[] counts = new int[K + 1];
    for (int elem : arr) {
        counts[elem] += 1;
    }
    // we now overwrite our original counts with the starting index
    // of each element in the final sorted array
    int startingIndex = 0;
    for (int i = 0; i < K + 1; i++) {
        int count = counts[i];
        counts[i] = startingIndex;
        startingIndex += count;
    }

    int sortedArray[] = new int[arr.length];
    for (int elem : arr) {
        sortedArray[counts[elem]] = elem;
        // since we have placed an item in index counts[elem], we need to
        // increment counts[elem] index by 1 so the next duplicate element
        // is placed in appropriate index
        counts[elem] += 1;
    }

    // common practice to copy over sorted list into original arr
    // it's fine to just return the sortedArray at this point as well
    for (int i = 0; i < arr.length; i++) {
        arr[i] = sortedArray[i];
    }
}
------------------------------------------------------
Radix sort

public void initializeSortedArray(int size) {
    if (mSortedArray == null) {
        mSortedArray = new int[size];
    }
}

public void countingSort(int[] arr, int placeVal) {
    // Sorts an array of integers where minimum value is 0 and maximum value is K
    int[] counts = new int[K];

    for (int elem : arr) {
        int current = elem / placeVal;
        counts[current % NUM_DIGITS] += 1
    }

    // we now overwrite our original counts with the starting index
    // of each digit in our group of digits
    int startingIndex = 0;
    for (int i = 0; i < mCounts.length; i++) {
        int count = counts[i];
        counts[i] = startingIndex;
        startingIndex += count;
    }

    int[] sortedArray = new int[arr.length];
    for (int elem : arr) {
        int current = elem / placeVal;
        sortedArray[counts[current % NUM_DIGITS]] = elem;
        // since we have placed an item in index mCounts[current % NUM_DIGITS],
        // we need to increment mCounts[current % NUM_DIGITS] index by 1 so the
        // next duplicate digit is placed in appropriate index
        counts[current % NUM_DIGITS] += 1;
    }

    // common practice to copy over sorted list into original arr
    // it's fine to just return the sortedArray at this point as well
    for (int i = 0; i < arr.length; i++) {
        arr[i] = sortedArray[i];
    }
}

public void radixSort(int[] arr) {
    int maxElem = Integer.MIN_VALUE;
    for (int elem : arr) {
        if (elem > maxElem) {
            maxElem = elem;
        }
    }

    int placeVal = 1;
    while (maxElem / placeVal > 0) {
        countingSort(arr, placeVal);
        placeVal *= 10;
    }
}
------------------------------------------------------
Bucket sort

public void bucketSort(int[] arr, int K) {
    List<List<Integer>> buckets = new ArrayList<ArrayList<Integer>>(K);
    int shift = Arrays.stream(arr).min().getAsInt();
    int maxValue = Arrays.stream(arr).max().getAsInt() - shft;
    // place elements into buckets
    double bucketSize = (double) maxValue / K;
    if (bucketSize < 1) {
        bucketSize = 1.0;
    }
    for (int elem : arr) {
        // same as K * arr[i] / max(lst)
        int index = (int) (elem - shift) / bucketSize;
        if (index == K) {
            // put the max value in the last bucket
            buckets[K - 1].add(elem);
        } else {
            buckets[index].add(elem);
        }
    }

    // sort individual buckets
    for (List<Integer> bucket : buckets) {
        Collections.sort(bucket);
    }

    // convert sorted buckets into final output
    List<Integer> sortedList = new ArrayList<Integer>();
    for (List<Integer> bucket : buckets) {
        sortedList.addAll(bucket);
    }

    // perfectly fine to just return sortedList here
    // but common practice is to mutate original array with sorted elements
    for (int i = 0; i < arr.length; i++) {
        arr[i] = sortedList.get(i);
    }
}
------------------------------------------------------
Bitwise operation: extract bit

var numIBit = (num >> i) & 1;
------------------------------------------------------
Bitwise operation: add bit

single = single | (bitValue << i);
------------------------------------------------------
Bitwise operation: get bits array

private int[] getBitsArray(int val) {
    int[] bits = new int[32];
    for (int i = 0; i < bits.length; i++) {
        int mask = 1 << i;
        bits[31 - i] = (val & mask) != 0 ? 1 : 0;
    }
    return bits;
}
------------------------------------------------------
Biwise operator: Bit count of a number (Brian Kernighan’s algorithm)

private int countSetBits(int mask) {
    var count = 0;
    while (mask != 0) {
        mask = mask & (mask - 1);
        count++;
    }
    return count;
}
------------------------------------------------------
Bitwise operation: is power of 2
(n > 0 && (n & (n - 1)) == 0)
------------------------------------------------------
Reverse integer

private int reverse(int num) {
    int result = 0;
    while (num > 0) {
        result = result * 10 + num % 10;
        num /= 10;
    }

    return result;
}
------------------------------------------------------
Grahams scan

    public int[][] outerTrees(int[][] trees) {
        // find lowest left point
        var minX = Integer.MAX_VALUE;
        var minY = Integer.MAX_VALUE;
        var minI = 0;
        for (int i = 0; i < trees.length; i++) {
            var point = trees[i];
            var x = point[0];
            var y = point[1];
            if (minY > y || (minY == y && minX > x)) {
                minY = y;
                minX = x;
                minI = i;
            }
        }

        //swap the bottommost point with the first point
        swap(trees, 0, minI);

        var p0 = trees[0];
        //sort points based on polar angle with respect to the first point
        Arrays.sort(trees, 1, trees.length, (p1, p2) -> {
            int o = orientation(p0, p1, p2);
            if (o == 0) {
                return (distSq(p0, p2) >= distSq(p0, p1)) ? -1 : 1;
            }
            return (o == 2) ? -1 : 1;
        });

        //create an empty stack and push first three point
        var stack = new Stack<int[]>();
        stack.push(trees[0]);
        stack.push(trees[1]);
        stack.push(trees[2]);

        //process remaining n - 3 points
        for (int i = 3; i < trees.length; i++) {
            while (stack.size() > 1 && orientation(nextToTop(stack), stack.peek(), trees[i]) != 2) {
                stack.pop();
            }
            stack.push(trees[i]);
        }

        var result = new int[stack.size()][2];
        for (int i = stack.size() - 1; i >= 0; i--) {
            result[i] = stack.pop();
        }
        return result;

    }

    private int[] nextToTop(Stack<int[]> stack) {
        var top = stack.pop();
        var next = stack.peek();
        stack.push(top);
        return next;
    }

    private int orientation(int[] p0, int[] p1, int[] p2) {
        var val = (p1[1] - p0[1]) * (p2[0] - p1[0]) -
                (p1[0] - p0[0]) * (p2[1] - p1[1]);

        if (val == 0) return 0; // Collinear
        return (val > 0) ? 1 : 2; // Clockwise or Counterclockwise
    }

    private int distSq(int[] p0, int[] p1) {
        return (int) (Math.pow(p1[1] - p0[1], 2) + Math.pow(p1[0] - p0[0], 2));
    }

    private void swap(int[][] trees, int a, int b) {
        var temp = trees[a];
        trees[a] = trees[b];
        trees[b] = temp;
    }
------------------------------------------------------